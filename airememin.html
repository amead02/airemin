<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Hand Theremin</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            background-color: #121212;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Top Control Bar */
        #controls-area {
            background: #1e1e1e;
            padding: 15px 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            z-index: 20;
            border-bottom: 1px solid #333;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        label {
            font-size: 0.7rem;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        select, input[type="range"] {
            background: #2a2a2a;
            color: white;
            border: 1px solid #444;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            outline: none;
            cursor: pointer;
            min-width: 100px;
        }

        select:hover { border-color: #00d2ff; }
        select:focus { border-color: #00d2ff; }
        
        button#start-btn {
            background: #00d2ff;
            color: #000;
            font-weight: bold;
            border: none;
            padding: 10px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 0.9rem;
            text-transform: uppercase;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.3);
        }
        button#start-btn:hover { background-color: #fff; transform: scale(1.05); }
        button#start-btn:disabled { background-color: #333; color: #555; cursor: default; box-shadow: none; transform: none; }

        /* Main Viewport */
        #canvas-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .loading-msg {
            position: absolute;
            color: #00d2ff;
            font-size: 1.5rem;
            display: none;
            z-index: 30;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
        }

        /* Video is hidden, we draw to canvas */
        video { display: none; }

        /* Canvas Layers */
        
        /* 1. Camera Feed & Hand Skeleton (Mirrored) */
        #output_canvas {
            position: absolute;
            transform: scaleX(-1); /* Mirror effect */
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* 2. HUD / Grid Lines (Not Mirrored, drawn directly) */
        #hud_canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="controls-area">
    <button id="start-btn">Start Camera & Audio</button>
    
    <div class="control-group">
        <label>Waveform</label>
        <select id="tone-select">
            <option value="sine">Sine (Pure)</option>
            <option value="triangle">Triangle (Soft)</option>
            <option value="sawtooth" selected>Sawtooth (Bright)</option>
            <option value="square">Square (Retro)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Key</label>
        <select id="key-select">
            <option value="C" selected>C</option>
            <option value="C#">C# / Db</option>
            <option value="D">D</option>
            <option value="D#">D# / Eb</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="F#">F# / Gb</option>
            <option value="G">G</option>
            <option value="G#">G# / Ab</option>
            <option value="A">A</option>
            <option value="A#">A# / Bb</option>
            <option value="B">B</option>
        </select>
    </div>

    <div class="control-group">
        <label>Scale</label>
        <select id="scale-select">
            <option value="major">Major</option>
            <option value="minor" selected>Minor</option>
            <option value="pentatonic_major">Pentatonic Maj</option>
            <option value="pentatonic_minor">Pentatonic Min</option>
            <option value="blues">Blues</option>
            <option value="chromatic">Chromatic</option>
        </select>
    </div>

    <div class="control-group">
        <label>Reverb</label>
        <input type="range" id="reverb-slider" min="0" max="100" value="40">
    </div>
</div>

<div id="canvas-container">
    <div class="loading-msg" id="loading-msg">Loading AI Vision Model...</div>
    <video id="input_video"></video>
    <canvas id="output_canvas"></canvas>
    <canvas id="hud_canvas"></canvas>
</div>

<script>
    /**
     * =========================================================
     * 1. AUDIO ENGINE
     * Uses Web Audio API for synthesis, filtering, and reverb.
     * =========================================================
     */
    const AudioEngine = (() => {
        let ctx;
        let masterGain, osc, filter, reverbNode, reverbGain;
        
        let isPlaying = false;
        let activeScale = []; // Stores { freq, noteName }

        const NOTES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const SCALES = {
            major: [0, 2, 4, 5, 7, 9, 11],
            minor: [0, 2, 3, 5, 7, 8, 10],
            pentatonic_major: [0, 2, 4, 7, 9],
            pentatonic_minor: [0, 3, 5, 7, 10],
            blues: [0, 3, 5, 6, 7, 10],
            chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        };

        // Procedural Reverb (creates a synthetic room impulse)
        function createImpulseResponse(duration, decay) {
            const rate = ctx.sampleRate;
            const length = rate * duration;
            const impulse = ctx.createBuffer(2, length, rate);
            const L = impulse.getChannelData(0);
            const R = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const n = i / length;
                // Noise * Exponential Decay
                const noise = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
                L[i] = noise;
                R[i] = noise;
            }
            return impulse;
        }

        return {
            init: () => {
                if (ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                ctx = new AudioContext();

                // 1. Oscillator (Source)
                osc = ctx.createOscillator();
                osc.type = document.getElementById('tone-select').value;
                osc.start();

                // 2. Filter (Tone Control)
                filter = ctx.createBiquadFilter();
                filter.type = "lowpass";
                filter.Q.value = 5; // Resonance

                // 3. Gain (Volume/Envelope)
                masterGain = ctx.createGain();
                masterGain.gain.value = 0; // Start silent

                // 4. Reverb Chain
                reverbNode = ctx.createConvolver();
                reverbNode.buffer = createImpulseResponse(2.5, 2.0); // 2.5s tail
                reverbGain = ctx.createGain();
                reverbGain.gain.value = document.getElementById('reverb-slider').value / 100;

                // Graph Connections
                // Osc -> Filter -> MasterGain -> Destination (Dry)
                //                             -> ReverbGain -> Reverb -> Destination (Wet)
                osc.connect(filter);
                filter.connect(masterGain);
                masterGain.connect(ctx.destination);
                
                masterGain.connect(reverbGain);
                reverbGain.connect(reverbNode);
                reverbNode.connect(ctx.destination);

                AudioEngine.updateScale();
            },

            // Recalculate the valid frequencies based on UI selection
            updateScale: () => {
                const rootKey = document.getElementById('key-select').value;
                const scaleType = document.getElementById('scale-select').value;
                const rootIndex = NOTES.indexOf(rootKey);
                const intervals = SCALES[scaleType];

                activeScale = [];
                // Range: C3 to C6 (3 Octaves)
                const startOctave = 3;
                const endOctave = 5;

                for (let oct = startOctave; oct <= endOctave; oct++) {
                    intervals.forEach(interval => {
                        const noteVal = (oct + 1) * 12 + ((rootIndex + interval) % 12);
                        const freq = 440 * Math.pow(2, (noteVal - 69) / 12);
                        const name = NOTES[(rootIndex + interval) % 12] + oct;
                        activeScale.push({ freq, name });
                    });
                }
                // Sort low to high
                activeScale.sort((a, b) => a.freq - b.freq);
            },

            // Called every frame by the vision loop
            updateSound: (pinch, x, y) => {
                if (!ctx) return null;
                const now = ctx.currentTime;

                // 1. PINCH (Volume Gate)
                if (pinch) {
                    if (!isPlaying) {
                        // Attack
                        masterGain.gain.cancelScheduledValues(now);
                        masterGain.gain.setTargetAtTime(0.5, now, 0.02);
                        isPlaying = true;
                    }
                } else {
                    if (isPlaying) {
                        // Release
                        masterGain.gain.cancelScheduledValues(now);
                        masterGain.gain.setTargetAtTime(0, now, 0.1);
                        isPlaying = false;
                    }
                }

                // 2. PITCH (Y-Axis) - Quantized
                // Invert Y (0 is top/high pitch, 1 is bottom/low pitch)
                const valY = 1.0 - Math.max(0, Math.min(1, y));
                
                // Map 0-1 to the array index of valid notes
                const noteIndex = Math.floor(valY * activeScale.length);
                const safeIndex = Math.max(0, Math.min(activeScale.length - 1, noteIndex));
                const targetNote = activeScale[safeIndex];

                // Glide to note (Portamento)
                osc.frequency.setTargetAtTime(targetNote.freq, now, 0.05);

                // 3. FILTER (X-Axis) - Continuous
                // Mirror logic: User physical Right = Screen Right = x near 0 (in Camera) -> x near 1 (in Canvas Logic?)
                // MediaPipe X: 0 (Left of frame) -> 1 (Right of frame).
                // Our Canvas is Mirrored (scaleX(-1)).
                // We want: Physical Right = Open Filter (High Freq).
                // Physical Right is Camera Left (x -> 0).
                // So: x=0 -> Max Freq. x=1 -> Min Freq.
                const valX = 1.0 - Math.max(0, Math.min(1, x)); // 1.0 means Physical Right

                const minCutoff = 100;
                const maxCutoff = 10000;
                // Exponential mapping for filter feels more natural
                const cutoff = minCutoff * Math.pow(maxCutoff / minCutoff, valX);
                
                filter.frequency.setTargetAtTime(cutoff, now, 0.1);

                return {
                    currentNote: targetNote,
                    cutoff: cutoff,
                    activeScale: activeScale,
                    playing: isPlaying
                };
            },

            setTone: (type) => { if (osc) osc.type = type; },
            setReverb: (val) => { if (reverbGain) reverbGain.gain.value = val / 100; },
            resume: () => { if (ctx && ctx.state === 'suspended') ctx.resume(); }
        };
    })();

    /**
     * =========================================================
     * 2. VISION & APP LOGIC
     * Handles Camera, MediaPipe, Canvas Drawing, and HUD.
     * =========================================================
     */
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const hudCanvas = document.getElementById('hud_canvas');
    const hudCtx = hudCanvas.getContext('2d');
    
    const startBtn = document.getElementById('start-btn');
    const loadingMsg = document.getElementById('loading-msg');

    // Handle Resize
    function resize() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        hudCanvas.width = window.innerWidth;
        hudCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Setup MediaPipe Hands
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    hands.onResults(onResults);

    // Setup Camera (triggered by button)
    let camera;
    startBtn.addEventListener('click', async () => {
        AudioEngine.init();
        AudioEngine.resume();
        
        startBtn.disabled = true;
        startBtn.innerText = "Active";
        loadingMsg.style.display = 'block';

        camera = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280,
            height: 720
        });
        camera.start();
    });

    // UI Listeners
    document.getElementById('tone-select').addEventListener('change', (e) => AudioEngine.setTone(e.target.value));
    document.getElementById('reverb-slider').addEventListener('input', (e) => AudioEngine.setReverb(e.target.value));
    document.getElementById('key-select').addEventListener('change', AudioEngine.updateScale);
    document.getElementById('scale-select').addEventListener('change', AudioEngine.updateScale);

    // Main Loop
    function onResults(results) {
        loadingMsg.style.display = 'none';

        // 1. Draw Video Feed
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        // 2. Process Hand Data
        let audioState = null;
        let indexTip = null;
        let pinchActive = false;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // Draw Skeleton
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00d2ff', lineWidth: 2});
            drawLandmarks(canvasCtx, landmarks, {color: '#ffffff', lineWidth: 1, radius: 4});

            indexTip = landmarks[8];
            const thumbTip = landmarks[4];

            // Pinch Detection (Euclidean distance)
            const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            pinchActive = dist < 0.05; // Pinch Threshold

            // Update Audio
            audioState = AudioEngine.updateSound(pinchActive, indexTip.x, indexTip.y);
        } else {
            // Silence if no hand
            AudioEngine.updateSound(false, 0, 0);
        }
        canvasCtx.restore();

        // 3. Draw HUD (Grid & Info)
        drawHUD(audioState, indexTip, pinchActive);
    }

    function drawHUD(audioState, indexTip, pinchActive) {
        hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
        
        if (!audioState) return; // Scale not ready

        const w = hudCanvas.width;
        const h = hudCanvas.height;
        const scale = audioState.activeScale;
        const step = h / scale.length;

        hudCtx.textAlign = "right";
        hudCtx.font = "12px monospace";
        hudCtx.lineWidth = 1;

        // Draw Pitch Grid
        for (let i = 0; i < scale.length; i++) {
            const y = h - (i * step); // Bottom to Top
            
            // Grid Line
            hudCtx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            hudCtx.beginPath();
            hudCtx.moveTo(0, y);
            hudCtx.lineTo(w, y);
            hudCtx.stroke();

            // Note Label (Only root notes or all notes if zoomed)
            const note = scale[i];
            const isRoot = note.name.startsWith(document.getElementById('key-select').value);
            
            if (isRoot) {
                hudCtx.fillStyle = "rgba(0, 210, 255, 0.8)";
                hudCtx.fillText(note.name, w - 10, y - 5);
                hudCtx.fillStyle = "rgba(0, 210, 255, 0.1)";
                hudCtx.fillRect(0, y - step, w, step);
            } else {
                hudCtx.fillStyle = "rgba(255, 255, 255, 0.3)";
                hudCtx.fillText(note.name, w - 10, y - 5);
            }
        }

        // Highlight Active Note
        if (indexTip) {
            // Calculate which note bucket we are in
            const valY = 1.0 - Math.max(0, Math.min(1, indexTip.y));
            const activeIndex = Math.floor(valY * scale.length);
            const safeIndex = Math.max(0, Math.min(scale.length - 1, activeIndex));
            
            // Highlight Bar
            const barY = h - ((safeIndex + 1) * step);
            hudCtx.fillStyle = pinchActive ? "rgba(0, 255, 136, 0.4)" : "rgba(255, 255, 255, 0.2)";
            hudCtx.fillRect(0, barY, w, step);

            // Draw Cursor (Un-mirror X for HUD drawing)
            const cursorX = (1.0 - indexTip.x) * w; 
            const cursorY = indexTip.y * h;

            hudCtx.beginPath();
            hudCtx.arc(cursorX, cursorY, pinchActive ? 25 : 15, 0, 2 * Math.PI);
            hudCtx.strokeStyle = pinchActive ? "#00ff88" : "#00d2ff";
            hudCtx.lineWidth = 3;
            hudCtx.stroke();

            // Text Info
            hudCtx.fillStyle = "#fff";
            hudCtx.font = "bold 20px sans-serif";
            hudCtx.textAlign = "center";
            const text = pinchActive ? audioState.currentNote.name : "Pinch to Play";
            hudCtx.fillText(text, cursorX, cursorY - 40);
            
            hudCtx.font = "12px monospace";
            hudCtx.fillStyle = "#aaa";
            hudCtx.fillText(`Filter: ${Math.round(audioState.cutoff)}Hz`, cursorX, cursorY - 25);
        }
    }

</script>
</body>
</html>
